# é‡åŒ–äº¤æ˜“ç³»ç»Ÿå¼€å‘èµ·æ­¥æŒ‡å—

## ğŸ¯ å¼€å‘ä¼˜å…ˆçº§ä¸è·¯çº¿å›¾

åŸºäºä¸¤äººå›¢é˜Ÿçš„å®é™…æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦æŒ‰ç…§ä»¥ä¸‹ä¼˜å…ˆçº§æ¥æ„å»ºé‡åŒ–äº¤æ˜“ç³»ç»Ÿï¼š

### ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šåŸºç¡€è®¾æ–½æ­å»ºï¼ˆç¬¬1-2å‘¨ï¼‰
```
æ ¸å¿ƒä»»åŠ¡:
â”œâ”€â”€ å¼€å‘ç¯å¢ƒé…ç½®
â”œâ”€â”€ æ•°æ®è·å–ç³»ç»Ÿ
â”œâ”€â”€ åŸºç¡€å·¥å…·åº“å»ºè®¾
â””â”€â”€ ç‰ˆæœ¬æ§åˆ¶ä¸åä½œ
```

### ç¬¬äºŒä¼˜å…ˆçº§ï¼šç­–ç•¥ç ”å‘æ¡†æ¶ï¼ˆç¬¬3-4å‘¨ï¼‰
```
æ ¸å¿ƒä»»åŠ¡:
â”œâ”€â”€ å›æµ‹å¼•æ“å¼€å‘
â”œâ”€â”€ å› å­è®¡ç®—æ¡†æ¶
â”œâ”€â”€ ç»©æ•ˆè¯„ä¼°ç³»ç»Ÿ
â””â”€â”€ ç­–ç•¥æ¨¡æ¿å»ºè®¾
```

### ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šäº¤æ˜“æ‰§è¡Œç³»ç»Ÿï¼ˆç¬¬5-8å‘¨ï¼‰
```
æ ¸å¿ƒä»»åŠ¡:
â”œâ”€â”€ æ¨¡æ‹Ÿäº¤æ˜“ç³»ç»Ÿ
â”œâ”€â”€ è®¢å•ç®¡ç†ç³»ç»Ÿ
â”œâ”€â”€ é£é™©æ§åˆ¶æ¨¡å—
â””â”€â”€ å®ç›˜äº¤æ˜“æ¥å£
```

---

## ğŸ› ï¸ ç¬¬ä¸€æ­¥ï¼šå¼€å‘ç¯å¢ƒæ­å»º

### 1.1 æŠ€æœ¯æ ˆé€‰æ‹©

#### æ ¸å¿ƒå¼€å‘è¯­è¨€ï¼šPython 3.9+
```python
# æ¨èç†ç”±ï¼š
# 1. ä¸°å¯Œçš„é‡‘èæ•°æ®å¤„ç†åº“
# 2. å¼ºå¤§çš„æœºå™¨å­¦ä¹ ç”Ÿæ€
# 3. æ´»è·ƒçš„é‡åŒ–ç¤¾åŒº
# 4. å¿«é€ŸåŸå‹å¼€å‘èƒ½åŠ›
```

#### å¿…å¤‡Pythonåº“æ¸…å•
```python
# æ•°æ®å¤„ç†
numpy>=1.21.0          # æ•°å€¼è®¡ç®—åŸºç¡€
pandas>=1.3.0          # æ•°æ®åˆ†æå¤„ç†
scipy>=1.7.0           # ç§‘å­¦è®¡ç®—

# é‡‘èæ•°æ®
yfinance>=0.1.70       # å…è´¹è‚¡ç¥¨æ•°æ®
quandl>=3.7.0          # é‡‘èæ•°æ®API
ccxt>=2.5.0            # åŠ å¯†è´§å¸æ•°æ®
fundamentus>=0.3.0     # åŸºæœ¬é¢æ•°æ®

# é‡åŒ–åˆ†æ
zipline-reloaded>=2.2.0  # å›æµ‹æ¡†æ¶
backtrader>=1.9.76     # å›æµ‹å¼•æ“
ta-lib>=0.4.24         # æŠ€æœ¯æŒ‡æ ‡
empyrical>=0.5.5       # ç»©æ•ˆåˆ†æ

# æœºå™¨å­¦ä¹ 
scikit-learn>=1.0.0    # æœºå™¨å­¦ä¹ 
lightgbm>=3.3.0        # æ¢¯åº¦æå‡
xgboost>=1.5.0         # æç«¯æ¢¯åº¦æå‡
tensorflow>=2.8.0      # æ·±åº¦å­¦ä¹ 

# å¯è§†åŒ–
matplotlib>=3.5.0      # åŸºç¡€ç»˜å›¾
seaborn>=0.11.0        # ç»Ÿè®¡ç»˜å›¾
plotly>=5.6.0          # äº¤äº’å¼å›¾è¡¨

# æ•°æ®åº“
sqlalchemy>=1.4.0      # ORMæ¡†æ¶
psycopg2>=2.9.0        # PostgreSQLé©±åŠ¨
redis>=4.1.0           # ç¼“å­˜æ•°æ®åº“

# Webå¼€å‘
fastapi>=0.75.0        # APIæ¡†æ¶
streamlit>=1.8.0       # å¿«é€ŸWebåº”ç”¨
jupyter>=1.0.0         # äº¤äº’å¼å¼€å‘

# å·¥å…·åº“
requests>=2.27.0       # HTTPè¯·æ±‚
schedule>=1.1.0        # ä»»åŠ¡è°ƒåº¦
loguru>=0.6.0          # æ—¥å¿—ç®¡ç†
pydantic>=1.9.0        # æ•°æ®éªŒè¯
```

### 1.2 å¼€å‘ç¯å¢ƒé…ç½®

#### åˆ›å»ºé¡¹ç›®ç»“æ„
```bash
# é¡¹ç›®æ ¹ç›®å½•ç»“æ„
quant-trading-system/
â”œâ”€â”€ config/                 # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py        # ç³»ç»Ÿé…ç½®
â”‚   â””â”€â”€ database.py        # æ•°æ®åº“é…ç½®
â”œâ”€â”€ data/                  # æ•°æ®å­˜å‚¨
â”‚   â”œâ”€â”€ raw/              # åŸå§‹æ•°æ®
â”‚   â”œâ”€â”€ processed/        # å¤„ç†åæ•°æ®
â”‚   â””â”€â”€ backtest/         # å›æµ‹æ•°æ®
â”œâ”€â”€ src/                   # æºä»£ç 
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data/             # æ•°æ®æ¨¡å—
â”‚   â”œâ”€â”€ strategy/         # ç­–ç•¥æ¨¡å—
â”‚   â”œâ”€â”€ backtest/         # å›æµ‹æ¨¡å—
â”‚   â”œâ”€â”€ trading/          # äº¤æ˜“æ¨¡å—
â”‚   â”œâ”€â”€ risk/             # é£é™©æ¨¡å—
â”‚   â””â”€â”€ utils/            # å·¥å…·æ¨¡å—
â”œâ”€â”€ tests/                 # æµ‹è¯•ä»£ç 
â”œâ”€â”€ notebooks/             # Jupyterç¬”è®°æœ¬
â”œâ”€â”€ docs/                  # æ–‡æ¡£
â”œâ”€â”€ requirements.txt       # ä¾èµ–åŒ…
â”œâ”€â”€ setup.py              # å®‰è£…è„šæœ¬
â””â”€â”€ README.md             # é¡¹ç›®è¯´æ˜
```

#### è™šæ‹Ÿç¯å¢ƒè®¾ç½®
```bash
# åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ
python -m venv quant_env

# æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ (macOS)
source quant_env/bin/activate

# å‡çº§pip
pip install --upgrade pip

# å®‰è£…åŸºç¡€ä¾èµ–
pip install -r requirements.txt
```

### 1.3 ç‰ˆæœ¬æ§åˆ¶é…ç½®

#### Gitä»“åº“åˆå§‹åŒ–
```bash
# åˆå§‹åŒ–Gitä»“åº“
git init

# åˆ›å»º.gitignoreæ–‡ä»¶
echo "# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
quant_env/
venv/
ENV/
env/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Data files
*.csv
*.h5
*.pkl
*.parquet

# Config files with secrets
.env
config/secrets.py

# Logs
*.log
logs/

# Jupyter Notebook
.ipynb_checkpoints

# Database
*.db
*.sqlite3" > .gitignore

# é¦–æ¬¡æäº¤
git add .
git commit -m "Initial project setup"
```

---

## ğŸ“Š ç¬¬äºŒæ­¥ï¼šæ•°æ®è·å–ç³»ç»Ÿ

### 2.1 æ•°æ®æºé…ç½®

#### å…è´¹æ•°æ®æºï¼ˆèµ·æ­¥é˜¶æ®µï¼‰
```python
# src/data/data_sources.py

import yfinance as yf
import pandas as pd
from typing import List, Optional
from datetime import datetime, timedelta

class DataManager:
    """
    æ•°æ®ç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†å„ç§æ•°æ®æº
    """
    
    def __init__(self):
        self.cache = {}  # ç®€å•å†…å­˜ç¼“å­˜
    
    def get_stock_data(self, 
                      symbols: List[str], 
                      start_date: str, 
                      end_date: str,
                      interval: str = '1d') -> pd.DataFrame:
        """
        è·å–è‚¡ç¥¨ä»·æ ¼æ•°æ®
        
        Args:
            symbols: è‚¡ç¥¨ä»£ç åˆ—è¡¨
            start_date: å¼€å§‹æ—¥æœŸ 'YYYY-MM-DD'
            end_date: ç»“æŸæ—¥æœŸ 'YYYY-MM-DD'
            interval: æ•°æ®é¢‘ç‡ ('1d', '1h', '5m')
            
        Returns:
            åŒ…å«OHLCVæ•°æ®çš„DataFrame
        """
        cache_key = f"{'-'.join(symbols)}_{start_date}_{end_date}_{interval}"
        
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        try:
            # ä½¿ç”¨yfinanceè·å–æ•°æ®
            data = yf.download(
                tickers=symbols,
                start=start_date,
                end=end_date,
                interval=interval,
                group_by='ticker',
                auto_adjust=True,
                prepost=True,
                threads=True
            )
            
            # ç¼“å­˜æ•°æ®
            self.cache[cache_key] = data
            return data
            
        except Exception as e:
            print(f"æ•°æ®è·å–å¤±è´¥: {e}")
            return pd.DataFrame()
    
    def get_sp500_symbols(self) -> List[str]:
        """
        è·å–æ ‡æ™®500æˆåˆ†è‚¡åˆ—è¡¨
        
        Returns:
            è‚¡ç¥¨ä»£ç åˆ—è¡¨
        """
        try:
            # ä»Wikipediaè·å–S&P500åˆ—è¡¨
            url = 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'
            tables = pd.read_html(url)
            sp500_table = tables[0]
            return sp500_table['Symbol'].tolist()
        except Exception as e:
            print(f"è·å–S&P500åˆ—è¡¨å¤±è´¥: {e}")
            # è¿”å›ä¸€äº›å¸¸è§è‚¡ç¥¨ä½œä¸ºå¤‡é€‰
            return ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'JPM', 'JNJ', 'V']
    
    def get_market_data(self, start_date: str, end_date: str) -> dict:
        """
        è·å–å¸‚åœºåŸºå‡†æ•°æ®
        
        Args:
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
            
        Returns:
            åŒ…å«å„ç§å¸‚åœºæŒ‡æ•°çš„å­—å…¸
        """
        benchmarks = {
            'SPY': 'S&P 500 ETF',
            'QQQ': 'NASDAQ 100 ETF', 
            'IWM': 'Russell 2000 ETF',
            'TLT': '20+ Year Treasury Bond ETF',
            'GLD': 'Gold ETF',
            'VIX': 'Volatility Index'
        }
        
        market_data = {}
        for symbol, name in benchmarks.items():
            try:
                data = self.get_stock_data([symbol], start_date, end_date)
                if not data.empty:
                    market_data[symbol] = data
            except Exception as e:
                print(f"è·å–{name}æ•°æ®å¤±è´¥: {e}")
        
        return market_data
```

### 2.2 æ•°æ®å­˜å‚¨ç³»ç»Ÿ

#### æ•°æ®åº“é…ç½®
```python
# config/database.py

from sqlalchemy import create_engine, MetaData
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

# æ•°æ®åº“é…ç½®
DATABASE_URL = os.getenv(
    'DATABASE_URL', 
    'postgresql://username:password@localhost:5432/quant_db'
)

# åˆ›å»ºæ•°æ®åº“å¼•æ“
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """
    è·å–æ•°æ®åº“ä¼šè¯
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# æ•°æ®è¡¨æ¨¡å‹
from sqlalchemy import Column, Integer, String, Float, DateTime, Index

class StockPrice(Base):
    """
    è‚¡ç¥¨ä»·æ ¼æ•°æ®è¡¨
    """
    __tablename__ = 'stock_prices'
    
    id = Column(Integer, primary_key=True, index=True)
    symbol = Column(String, index=True)
    date = Column(DateTime, index=True)
    open = Column(Float)
    high = Column(Float)
    low = Column(Float)
    close = Column(Float)
    volume = Column(Integer)
    
    # åˆ›å»ºå¤åˆç´¢å¼•
    __table_args__ = (
        Index('idx_symbol_date', 'symbol', 'date'),
    )

class StrategyPerformance(Base):
    """
    ç­–ç•¥ç»©æ•ˆæ•°æ®è¡¨
    """
    __tablename__ = 'strategy_performance'
    
    id = Column(Integer, primary_key=True, index=True)
    strategy_name = Column(String, index=True)
    date = Column(DateTime, index=True)
    returns = Column(Float)
    cumulative_returns = Column(Float)
    drawdown = Column(Float)
    positions = Column(String)  # JSONæ ¼å¼å­˜å‚¨æŒä»“
```

---

## ğŸ§® ç¬¬ä¸‰æ­¥ï¼šå› å­è®¡ç®—æ¡†æ¶

### 3.1 æŠ€æœ¯æŒ‡æ ‡åº“

```python
# src/strategy/factors.py

import pandas as pd
import numpy as np
from typing import Union, Optional
import talib

class TechnicalFactors:
    """
    æŠ€æœ¯æŒ‡æ ‡å› å­è®¡ç®—ç±»
    """
    
    @staticmethod
    def sma(prices: pd.Series, window: int) -> pd.Series:
        """
        ç®€å•ç§»åŠ¨å¹³å‡çº¿
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            window: çª—å£æœŸ
            
        Returns:
            SMAåºåˆ—
        """
        return prices.rolling(window=window).mean()
    
    @staticmethod
    def ema(prices: pd.Series, window: int) -> pd.Series:
        """
        æŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            window: çª—å£æœŸ
            
        Returns:
            EMAåºåˆ—
        """
        return prices.ewm(span=window).mean()
    
    @staticmethod
    def rsi(prices: pd.Series, window: int = 14) -> pd.Series:
        """
        ç›¸å¯¹å¼ºå¼±æŒ‡æ•°
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            window: çª—å£æœŸ
            
        Returns:
            RSIåºåˆ—
        """
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
        rs = gain / loss
        return 100 - (100 / (1 + rs))
    
    @staticmethod
    def bollinger_bands(prices: pd.Series, window: int = 20, num_std: float = 2) -> dict:
        """
        å¸ƒæ—å¸¦æŒ‡æ ‡
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            window: çª—å£æœŸ
            num_std: æ ‡å‡†å·®å€æ•°
            
        Returns:
            åŒ…å«ä¸Šè½¨ã€ä¸­è½¨ã€ä¸‹è½¨çš„å­—å…¸
        """
        sma = prices.rolling(window=window).mean()
        std = prices.rolling(window=window).std()
        
        return {
            'upper': sma + (std * num_std),
            'middle': sma,
            'lower': sma - (std * num_std)
        }
    
    @staticmethod
    def macd(prices: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> dict:
        """
        MACDæŒ‡æ ‡
        
        Args:
            prices: ä»·æ ¼åºåˆ—
            fast: å¿«çº¿å‘¨æœŸ
            slow: æ…¢çº¿å‘¨æœŸ
            signal: ä¿¡å·çº¿å‘¨æœŸ
            
        Returns:
            åŒ…å«MACDçº¿ã€ä¿¡å·çº¿ã€æŸ±çŠ¶å›¾çš„å­—å…¸
        """
        ema_fast = prices.ewm(span=fast).mean()
        ema_slow = prices.ewm(span=slow).mean()
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        
        return {
            'macd': macd_line,
            'signal': signal_line,
            'histogram': histogram
        }

class FundamentalFactors:
    """
    åŸºæœ¬é¢å› å­è®¡ç®—ç±»
    """
    
    @staticmethod
    def price_to_earnings(price: pd.Series, earnings: pd.Series) -> pd.Series:
        """
        å¸‚ç›ˆç‡
        
        Args:
            price: è‚¡ä»·åºåˆ—
            earnings: æ¯è‚¡æ”¶ç›Šåºåˆ—
            
        Returns:
            PEæ¯”ç‡åºåˆ—
        """
        return price / earnings
    
    @staticmethod
    def price_to_book(price: pd.Series, book_value: pd.Series) -> pd.Series:
        """
        å¸‚å‡€ç‡
        
        Args:
            price: è‚¡ä»·åºåˆ—
            book_value: æ¯è‚¡å‡€èµ„äº§åºåˆ—
            
        Returns:
            PBæ¯”ç‡åºåˆ—
        """
        return price / book_value
    
    @staticmethod
    def return_on_equity(net_income: pd.Series, shareholders_equity: pd.Series) -> pd.Series:
        """
        å‡€èµ„äº§æ”¶ç›Šç‡
        
        Args:
            net_income: å‡€åˆ©æ¶¦åºåˆ—
            shareholders_equity: è‚¡ä¸œæƒç›Šåºåˆ—
            
        Returns:
            ROEåºåˆ—
        """
        return net_income / shareholders_equity

class RiskFactors:
    """
    é£é™©å› å­è®¡ç®—ç±»
    """
    
    @staticmethod
    def volatility(returns: pd.Series, window: int = 20) -> pd.Series:
        """
        æ»šåŠ¨æ³¢åŠ¨ç‡
        
        Args:
            returns: æ”¶ç›Šç‡åºåˆ—
            window: çª—å£æœŸ
            
        Returns:
            æ³¢åŠ¨ç‡åºåˆ—
        """
        return returns.rolling(window=window).std() * np.sqrt(252)
    
    @staticmethod
    def beta(stock_returns: pd.Series, market_returns: pd.Series, window: int = 252) -> pd.Series:
        """
        æ»šåŠ¨Betaç³»æ•°
        
        Args:
            stock_returns: è‚¡ç¥¨æ”¶ç›Šç‡åºåˆ—
            market_returns: å¸‚åœºæ”¶ç›Šç‡åºåˆ—
            window: çª—å£æœŸ
            
        Returns:
            Betaç³»æ•°åºåˆ—
        """
        def rolling_beta(x, y):
            return np.cov(x, y)[0, 1] / np.var(y)
        
        return stock_returns.rolling(window=window).apply(
            lambda x: rolling_beta(x, market_returns.loc[x.index])
        )
    
    @staticmethod
    def max_drawdown(cumulative_returns: pd.Series) -> float:
        """
        æœ€å¤§å›æ’¤
        
        Args:
            cumulative_returns: ç´¯è®¡æ”¶ç›Šç‡åºåˆ—
            
        Returns:
            æœ€å¤§å›æ’¤å€¼
        """
        peak = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - peak) / peak
        return drawdown.min()
```

### 3.2 å› å­åˆæˆæ¡†æ¶

```python
# src/strategy/factor_engine.py

import pandas as pd
import numpy as np
from typing import Dict, List, Callable
from .factors import TechnicalFactors, FundamentalFactors, RiskFactors

class FactorEngine:
    """
    å› å­è®¡ç®—å¼•æ“
    """
    
    def __init__(self):
        self.technical = TechnicalFactors()
        self.fundamental = FundamentalFactors()
        self.risk = RiskFactors()
        self.factor_cache = {}
    
    def calculate_technical_factors(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        è®¡ç®—æŠ€æœ¯æŒ‡æ ‡å› å­
        
        Args:
            data: åŒ…å«OHLCVçš„ä»·æ ¼æ•°æ®
            
        Returns:
            æŠ€æœ¯å› å­DataFrame
        """
        factors = pd.DataFrame(index=data.index)
        
        # ä»·æ ¼ç›¸å…³å› å­
        factors['sma_5'] = self.technical.sma(data['Close'], 5)
        factors['sma_20'] = self.technical.sma(data['Close'], 20)
        factors['sma_60'] = self.technical.sma(data['Close'], 60)
        factors['ema_12'] = self.technical.ema(data['Close'], 12)
        factors['ema_26'] = self.technical.ema(data['Close'], 26)
        
        # åŠ¨é‡å› å­
        factors['rsi_14'] = self.technical.rsi(data['Close'], 14)
        factors['momentum_5'] = data['Close'].pct_change(5)
        factors['momentum_20'] = data['Close'].pct_change(20)
        
        # å¸ƒæ—å¸¦å› å­
        bb = self.technical.bollinger_bands(data['Close'])
        factors['bb_upper'] = bb['upper']
        factors['bb_lower'] = bb['lower']
        factors['bb_width'] = (bb['upper'] - bb['lower']) / bb['middle']
        factors['bb_position'] = (data['Close'] - bb['lower']) / (bb['upper'] - bb['lower'])
        
        # MACDå› å­
        macd = self.technical.macd(data['Close'])
        factors['macd'] = macd['macd']
        factors['macd_signal'] = macd['signal']
        factors['macd_histogram'] = macd['histogram']
        
        # æˆäº¤é‡å› å­
        factors['volume_sma_20'] = data['Volume'].rolling(20).mean()
        factors['volume_ratio'] = data['Volume'] / factors['volume_sma_20']
        
        return factors
    
    def calculate_cross_sectional_factors(self, data_dict: Dict[str, pd.DataFrame]) -> pd.DataFrame:
        """
        è®¡ç®—æˆªé¢å› å­ï¼ˆå¤šè‚¡ç¥¨å¯¹æ¯”ï¼‰
        
        Args:
            data_dict: è‚¡ç¥¨ä»£ç åˆ°ä»·æ ¼æ•°æ®çš„æ˜ å°„
            
        Returns:
            æˆªé¢å› å­DataFrame
        """
        # è·å–æ‰€æœ‰è‚¡ç¥¨çš„æ”¶ç›˜ä»·
        prices = pd.DataFrame({
            symbol: df['Close'] for symbol, df in data_dict.items()
        })
        
        # è®¡ç®—æ”¶ç›Šç‡
        returns = prices.pct_change()
        
        factors = pd.DataFrame(index=prices.index)
        
        # ç›¸å¯¹å¼ºåº¦å› å­
        for period in [5, 20, 60]:
            momentum = prices.pct_change(period)
            factors[f'relative_strength_{period}'] = momentum.rank(axis=1, pct=True)
        
        # æ³¢åŠ¨ç‡å› å­
        for window in [20, 60]:
            vol = returns.rolling(window).std()
            factors[f'volatility_rank_{window}'] = vol.rank(axis=1, pct=True)
        
        # æˆäº¤é‡å› å­
        volumes = pd.DataFrame({
            symbol: df['Volume'] for symbol, df in data_dict.items()
        })
        
        volume_ratio = volumes.div(volumes.rolling(20).mean())
        factors['volume_rank'] = volume_ratio.rank(axis=1, pct=True)
        
        return factors
    
    def neutralize_factors(self, factors: pd.DataFrame, 
                          industry_groups: pd.Series = None,
                          market_cap: pd.Series = None) -> pd.DataFrame:
        """
        å› å­ä¸­æ€§åŒ–å¤„ç†
        
        Args:
            factors: åŸå§‹å› å­æ•°æ®
            industry_groups: è¡Œä¸šåˆ†ç»„
            market_cap: å¸‚å€¼æ•°æ®
            
        Returns:
            ä¸­æ€§åŒ–åçš„å› å­æ•°æ®
        """
        neutralized_factors = factors.copy()
        
        for factor_name in factors.columns:
            factor_values = factors[factor_name].dropna()
            
            if len(factor_values) == 0:
                continue
            
            # è¡Œä¸šä¸­æ€§åŒ–
            if industry_groups is not None:
                industry_means = factor_values.groupby(industry_groups).mean()
                for industry, mean_val in industry_means.items():
                    mask = industry_groups == industry
                    neutralized_factors.loc[mask, factor_name] -= mean_val
            
            # å¸‚å€¼ä¸­æ€§åŒ–
            if market_cap is not None:
                # ä½¿ç”¨å¸‚å€¼åŠ æƒå¹³å‡è¿›è¡Œä¸­æ€§åŒ–
                weighted_mean = np.average(factor_values, weights=market_cap)
                neutralized_factors[factor_name] -= weighted_mean
        
        return neutralized_factors
    
    def combine_factors(self, factors: pd.DataFrame, 
                       weights: Dict[str, float] = None) -> pd.Series:
        """
        å› å­åˆæˆ
        
        Args:
            factors: å› å­æ•°æ®
            weights: å› å­æƒé‡å­—å…¸
            
        Returns:
            åˆæˆå› å­åºåˆ—
        """
        if weights is None:
            # ç­‰æƒé‡åˆæˆ
            weights = {col: 1.0/len(factors.columns) for col in factors.columns}
        
        # æ ‡å‡†åŒ–å› å­
        standardized_factors = factors.apply(lambda x: (x - x.mean()) / x.std())
        
        # åŠ æƒåˆæˆ
        combined_factor = pd.Series(0, index=factors.index)
        for factor_name, weight in weights.items():
            if factor_name in standardized_factors.columns:
                combined_factor += weight * standardized_factors[factor_name]
        
        return combined_factor
```

---

## ğŸ”„ ç¬¬å››æ­¥ï¼šå›æµ‹å¼•æ“å¼€å‘

### 4.1 åŸºç¡€å›æµ‹æ¡†æ¶

```python
# src/backtest/backtest_engine.py

import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Callable
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class BacktestEngine:
    """
    å›æµ‹å¼•æ“æ ¸å¿ƒç±»
    """
    
    def __init__(self, 
                 initial_capital: float = 1000000,
                 commission: float = 0.001,
                 slippage: float = 0.001):
        """
        åˆå§‹åŒ–å›æµ‹å¼•æ“
        
        Args:
            initial_capital: åˆå§‹èµ„é‡‘
            commission: æ‰‹ç»­è´¹ç‡
            slippage: æ»‘ç‚¹ç‡
        """
        self.initial_capital = initial_capital
        self.commission = commission
        self.slippage = slippage
        
        # å›æµ‹çŠ¶æ€
        self.current_capital = initial_capital
        self.positions = {}  # å½“å‰æŒä»“
        self.trades = []     # äº¤æ˜“è®°å½•
        self.portfolio_values = []  # ç»„åˆä»·å€¼å†å²
        self.returns = []    # æ”¶ç›Šç‡å†å²
        
    def reset(self):
        """
        é‡ç½®å›æµ‹çŠ¶æ€
        """
        self.current_capital = self.initial_capital
        self.positions = {}
        self.trades = []
        self.portfolio_values = []
        self.returns = []
    
    def calculate_portfolio_value(self, prices: Dict[str, float]) -> float:
        """
        è®¡ç®—å½“å‰ç»„åˆä»·å€¼
        
        Args:
            prices: å½“å‰ä»·æ ¼å­—å…¸
            
        Returns:
            ç»„åˆæ€»ä»·å€¼
        """
        portfolio_value = self.current_capital
        
        for symbol, shares in self.positions.items():
            if symbol in prices:
                portfolio_value += shares * prices[symbol]
        
        return portfolio_value
    
    def execute_trade(self, symbol: str, shares: int, price: float, timestamp: datetime):
        """
        æ‰§è¡Œäº¤æ˜“
        
        Args:
            symbol: è‚¡ç¥¨ä»£ç 
            shares: è‚¡æ•°ï¼ˆæ­£æ•°ä¹°å…¥ï¼Œè´Ÿæ•°å–å‡ºï¼‰
            price: äº¤æ˜“ä»·æ ¼
            timestamp: äº¤æ˜“æ—¶é—´
        """
        # è®¡ç®—äº¤æ˜“æˆæœ¬
        trade_value = abs(shares * price)
        commission_cost = trade_value * self.commission
        slippage_cost = trade_value * self.slippage
        total_cost = commission_cost + slippage_cost
        
        # æ›´æ–°æŒä»“
        if symbol not in self.positions:
            self.positions[symbol] = 0
        self.positions[symbol] += shares
        
        # æ›´æ–°ç°é‡‘
        self.current_capital -= shares * price + total_cost
        
        # è®°å½•äº¤æ˜“
        trade_record = {
            'timestamp': timestamp,
            'symbol': symbol,
            'shares': shares,
            'price': price,
            'commission': commission_cost,
            'slippage': slippage_cost,
            'total_cost': total_cost
        }
        self.trades.append(trade_record)
    
    def run_backtest(self, 
                    data: Dict[str, pd.DataFrame],
                    strategy_func: Callable,
                    start_date: str = None,
                    end_date: str = None) -> Dict:
        """
        è¿è¡Œå›æµ‹
        
        Args:
            data: è‚¡ç¥¨æ•°æ®å­—å…¸
            strategy_func: ç­–ç•¥å‡½æ•°
            start_date: å¼€å§‹æ—¥æœŸ
            end_date: ç»“æŸæ—¥æœŸ
            
        Returns:
            å›æµ‹ç»“æœå­—å…¸
        """
        self.reset()
        
        # è·å–æ—¥æœŸèŒƒå›´
        all_dates = set()
        for df in data.values():
            all_dates.update(df.index)
        all_dates = sorted(list(all_dates))
        
        if start_date:
            all_dates = [d for d in all_dates if d >= pd.to_datetime(start_date)]
        if end_date:
            all_dates = [d for d in all_dates if d <= pd.to_datetime(end_date)]
        
        # é€æ—¥å›æµ‹
        for date in all_dates:
            # è·å–å½“æ—¥æ•°æ®
            current_data = {}
            current_prices = {}
            
            for symbol, df in data.items():
                if date in df.index:
                    current_data[symbol] = df.loc[date]
                    current_prices[symbol] = df.loc[date, 'Close']
            
            if not current_data:
                continue
            
            # æ‰§è¡Œç­–ç•¥
            signals = strategy_func(current_data, self.positions, date)
            
            # æ‰§è¡Œäº¤æ˜“ä¿¡å·
            for symbol, signal in signals.items():
                if symbol in current_prices:
                    target_shares = signal.get('shares', 0)
                    current_shares = self.positions.get(symbol, 0)
                    trade_shares = target_shares - current_shares
                    
                    if trade_shares != 0:
                        self.execute_trade(
                            symbol=symbol,
                            shares=trade_shares,
                            price=current_prices[symbol],
                            timestamp=date
                        )
            
            # è®°å½•ç»„åˆä»·å€¼
            portfolio_value = self.calculate_portfolio_value(current_prices)
            self.portfolio_values.append({
                'date': date,
                'portfolio_value': portfolio_value,
                'cash': self.current_capital,
                'positions': self.positions.copy()
            })
        
        # è®¡ç®—æ”¶ç›Šç‡
        values = [pv['portfolio_value'] for pv in self.portfolio_values]
        self.returns = [0] + [(values[i] - values[i-1]) / values[i-1] 
                             for i in range(1, len(values))]
        
        return self.generate_performance_report()
    
    def generate_performance_report(self) -> Dict:
        """
        ç”Ÿæˆç»©æ•ˆæŠ¥å‘Š
        
        Returns:
            ç»©æ•ˆæŒ‡æ ‡å­—å…¸
        """
        if not self.portfolio_values:
            return {}
        
        # åŸºç¡€æ•°æ®
        values = [pv['portfolio_value'] for pv in self.portfolio_values]
        dates = [pv['date'] for pv in self.portfolio_values]
        returns = pd.Series(self.returns, index=dates)
        
        # è®¡ç®—ç»©æ•ˆæŒ‡æ ‡
        total_return = (values[-1] - values[0]) / values[0]
        annual_return = (1 + total_return) ** (252 / len(values)) - 1
        
        volatility = returns.std() * np.sqrt(252)
        sharpe_ratio = annual_return / volatility if volatility > 0 else 0
        
        # æœ€å¤§å›æ’¤
        cumulative_values = pd.Series(values, index=dates)
        peak = cumulative_values.expanding().max()
        drawdown = (cumulative_values - peak) / peak
        max_drawdown = drawdown.min()
        
        # èƒœç‡
        win_rate = (returns > 0).sum() / len(returns) if len(returns) > 0 else 0
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'win_rate': win_rate,
            'total_trades': len(self.trades),
            'final_value': values[-1],
            'portfolio_history': self.portfolio_values,
            'trade_history': self.trades
        }
```

### 4.2 ç­–ç•¥æ¨¡æ¿

```python
# src/strategy/strategy_templates.py

import pandas as pd
import numpy as np
from typing import Dict, Any
from datetime import datetime

class StrategyTemplate:
    """
    ç­–ç•¥æ¨¡æ¿åŸºç±»
    """
    
    def __init__(self, name: str):
        self.name = name
        self.parameters = {}
    
    def generate_signals(self, data: Dict[str, Any], 
                        positions: Dict[str, int], 
                        timestamp: datetime) -> Dict[str, Dict]:
        """
        ç”Ÿæˆäº¤æ˜“ä¿¡å·
        
        Args:
            data: å½“å‰å¸‚åœºæ•°æ®
            positions: å½“å‰æŒä»“
            timestamp: å½“å‰æ—¶é—´
            
        Returns:
            äº¤æ˜“ä¿¡å·å­—å…¸
        """
        raise NotImplementedError("å­ç±»å¿…é¡»å®ç°generate_signalsæ–¹æ³•")

class MeanReversionStrategy(StrategyTemplate):
    """
    å‡å€¼å›å½’ç­–ç•¥
    """
    
    def __init__(self, lookback_period: int = 20, 
                 entry_threshold: float = 2.0,
                 exit_threshold: float = 0.5,
                 max_position_size: int = 1000):
        super().__init__("MeanReversion")
        self.lookback_period = lookback_period
        self.entry_threshold = entry_threshold
        self.exit_threshold = exit_threshold
        self.max_position_size = max_position_size
        self.price_history = {}
    
    def generate_signals(self, data: Dict[str, Any], 
                        positions: Dict[str, int], 
                        timestamp: datetime) -> Dict[str, Dict]:
        """
        å‡å€¼å›å½’ç­–ç•¥ä¿¡å·ç”Ÿæˆ
        """
        signals = {}
        
        for symbol, stock_data in data.items():
            current_price = stock_data['Close']
            
            # æ›´æ–°ä»·æ ¼å†å²
            if symbol not in self.price_history:
                self.price_history[symbol] = []
            self.price_history[symbol].append(current_price)
            
            # ä¿æŒå†å²æ•°æ®é•¿åº¦
            if len(self.price_history[symbol]) > self.lookback_period:
                self.price_history[symbol] = self.price_history[symbol][-self.lookback_period:]
            
            # éœ€è¦è¶³å¤Ÿçš„å†å²æ•°æ®
            if len(self.price_history[symbol]) < self.lookback_period:
                continue
            
            # è®¡ç®—å‡å€¼å’Œæ ‡å‡†å·®
            prices = np.array(self.price_history[symbol])
            mean_price = np.mean(prices)
            std_price = np.std(prices)
            
            if std_price == 0:
                continue
            
            # è®¡ç®—Z-score
            z_score = (current_price - mean_price) / std_price
            current_position = positions.get(symbol, 0)
            
            # ç”Ÿæˆäº¤æ˜“ä¿¡å·
            if z_score > self.entry_threshold and current_position >= 0:
                # ä»·æ ¼è¿‡é«˜ï¼Œåšç©º
                signals[symbol] = {'shares': -self.max_position_size}
            elif z_score < -self.entry_threshold and current_position <= 0:
                # ä»·æ ¼è¿‡ä½ï¼Œåšå¤š
                signals[symbol] = {'shares': self.max_position_size}
            elif abs(z_score) < self.exit_threshold and current_position != 0:
                # å›å½’å‡å€¼ï¼Œå¹³ä»“
                signals[symbol] = {'shares': 0}
        
        return signals

class MomentumStrategy(StrategyTemplate):
    """
    åŠ¨é‡ç­–ç•¥
    """
    
    def __init__(self, short_window: int = 10, 
                 long_window: int = 30,
                 max_position_size: int = 1000):
        super().__init__("Momentum")
        self.short_window = short_window
        self.long_window = long_window
        self.max_position_size = max_position_size
        self.price_history = {}
    
    def generate_signals(self, data: Dict[str, Any], 
                        positions: Dict[str, int], 
                        timestamp: datetime) -> Dict[str, Dict]:
        """
        åŠ¨é‡ç­–ç•¥ä¿¡å·ç”Ÿæˆ
        """
        signals = {}
        
        for symbol, stock_data in data.items():
            current_price = stock_data['Close']
            
            # æ›´æ–°ä»·æ ¼å†å²
            if symbol not in self.price_history:
                self.price_history[symbol] = []
            self.price_history[symbol].append(current_price)
            
            # ä¿æŒå†å²æ•°æ®é•¿åº¦
            if len(self.price_history[symbol]) > self.long_window:
                self.price_history[symbol] = self.price_history[symbol][-self.long_window:]
            
            # éœ€è¦è¶³å¤Ÿçš„å†å²æ•°æ®
            if len(self.price_history[symbol]) < self.long_window:
                continue
            
            # è®¡ç®—ç§»åŠ¨å¹³å‡çº¿
            prices = np.array(self.price_history[symbol])
            short_ma = np.mean(prices[-self.short_window:])
            long_ma = np.mean(prices[-self.long_window:])
            
            current_position = positions.get(symbol, 0)
            
            # ç”Ÿæˆäº¤æ˜“ä¿¡å·
            if short_ma > long_ma and current_position <= 0:
                # çŸ­æœŸå‡çº¿ä¸Šç©¿é•¿æœŸå‡çº¿ï¼Œä¹°å…¥
                signals[symbol] = {'shares': self.max_position_size}
            elif short_ma < long_ma and current_position >= 0:
                # çŸ­æœŸå‡çº¿ä¸‹ç©¿é•¿æœŸå‡çº¿ï¼Œå–å‡º
                signals[symbol] = {'shares': -self.max_position_size}
        
        return signals

class PairsTradingStrategy(StrategyTemplate):
    """
    é…å¯¹äº¤æ˜“ç­–ç•¥
    """
    
    def __init__(self, pair_symbols: tuple, 
                 lookback_period: int = 60,
                 entry_threshold: float = 2.0,
                 exit_threshold: float = 0.5,
                 max_position_size: int = 500):
        super().__init__("PairsTrading")
        self.pair_symbols = pair_symbols
        self.lookback_period = lookback_period
        self.entry_threshold = entry_threshold
        self.exit_threshold = exit_threshold
        self.max_position_size = max_position_size
        self.spread_history = []
    
    def generate_signals(self, data: Dict[str, Any], 
                        positions: Dict[str, int], 
                        timestamp: datetime) -> Dict[str, Dict]:
        """
        é…å¯¹äº¤æ˜“ç­–ç•¥ä¿¡å·ç”Ÿæˆ
        """
        signals = {}
        
        symbol1, symbol2 = self.pair_symbols
        
        # æ£€æŸ¥ä¸¤åªè‚¡ç¥¨çš„æ•°æ®æ˜¯å¦éƒ½å­˜åœ¨
        if symbol1 not in data or symbol2 not in data:
            return signals
        
        price1 = data[symbol1]['Close']
        price2 = data[symbol2]['Close']
        
        # è®¡ç®—ä»·å·®
        spread = price1 - price2
        self.spread_history.append(spread)
        
        # ä¿æŒå†å²æ•°æ®é•¿åº¦
        if len(self.spread_history) > self.lookback_period:
            self.spread_history = self.spread_history[-self.lookback_period:]
        
        # éœ€è¦è¶³å¤Ÿçš„å†å²æ•°æ®
        if len(self.spread_history) < self.lookback_period:
            return signals
        
        # è®¡ç®—ä»·å·®çš„å‡å€¼å’Œæ ‡å‡†å·®
        spread_mean = np.mean(self.spread_history)
        spread_std = np.std(self.spread_history)
        
        if spread_std == 0:
            return signals
        
        # è®¡ç®—Z-score
        z_score = (spread - spread_mean) / spread_std
        
        current_pos1 = positions.get(symbol1, 0)
        current_pos2 = positions.get(symbol2, 0)
        
        # ç”Ÿæˆäº¤æ˜“ä¿¡å·
        if z_score > self.entry_threshold and current_pos1 >= 0:
            # ä»·å·®è¿‡å¤§ï¼Œåšç©ºsymbol1ï¼Œåšå¤šsymbol2
            signals[symbol1] = {'shares': -self.max_position_size}
            signals[symbol2] = {'shares': self.max_position_size}
        elif z_score < -self.entry_threshold and current_pos1 <= 0:
            # ä»·å·®è¿‡å°ï¼Œåšå¤šsymbol1ï¼Œåšç©ºsymbol2
            signals[symbol1] = {'shares': self.max_position_size}
            signals[symbol2] = {'shares': -self.max_position_size}
        elif abs(z_score) < self.exit_threshold and (current_pos1 != 0 or current_pos2 != 0):
            # ä»·å·®å›å½’ï¼Œå¹³ä»“
            signals[symbol1] = {'shares': 0}
            signals[symbol2] = {'shares': 0}
        
        return signals
```

---

## ğŸ“ˆ ç¬¬äº”æ­¥ï¼šç»©æ•ˆåˆ†æç³»ç»Ÿ

```python
# src/backtest/performance_analyzer.py

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List, Optional
import plotly.graph_objects as go
from plotly.subplots import make_subplots

class PerformanceAnalyzer:
    """
    ç»©æ•ˆåˆ†æå™¨
    """
    
    def __init__(self):
        self.metrics = {}
        self.benchmark_data = None
    
    def calculate_metrics(self, returns: pd.Series, 
                         benchmark_returns: pd.Series = None) -> Dict:
        """
        è®¡ç®—å…¨é¢çš„ç»©æ•ˆæŒ‡æ ‡
        
        Args:
            returns: ç­–ç•¥æ”¶ç›Šç‡åºåˆ—
            benchmark_returns: åŸºå‡†æ”¶ç›Šç‡åºåˆ—
            
        Returns:
            ç»©æ•ˆæŒ‡æ ‡å­—å…¸
        """
        metrics = {}
        
        # åŸºç¡€æ”¶ç›ŠæŒ‡æ ‡
        metrics['total_return'] = (1 + returns).prod() - 1
        metrics['annual_return'] = (1 + returns.mean()) ** 252 - 1
        metrics['volatility'] = returns.std() * np.sqrt(252)
        
        # é£é™©è°ƒæ•´æ”¶ç›ŠæŒ‡æ ‡
        if metrics['volatility'] > 0:
            metrics['sharpe_ratio'] = metrics['annual_return'] / metrics['volatility']
        else:
            metrics['sharpe_ratio'] = 0
        
        # ä¸‹è¡Œé£é™©æŒ‡æ ‡
        negative_returns = returns[returns < 0]
        if len(negative_returns) > 0:
            metrics['downside_deviation'] = negative_returns.std() * np.sqrt(252)
            metrics['sortino_ratio'] = metrics['annual_return'] / metrics['downside_deviation']
        else:
            metrics['downside_deviation'] = 0
            metrics['sortino_ratio'] = float('inf')
        
        # å›æ’¤æŒ‡æ ‡
        cumulative_returns = (1 + returns).cumprod()
        peak = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - peak) / peak
        
        metrics['max_drawdown'] = drawdown.min()
        metrics['avg_drawdown'] = drawdown[drawdown < 0].mean() if (drawdown < 0).any() else 0
        
        # èƒœç‡æŒ‡æ ‡
        metrics['win_rate'] = (returns > 0).sum() / len(returns)
        metrics['loss_rate'] = (returns < 0).sum() / len(returns)
        
        # ç›ˆäºæ¯”
        winning_returns = returns[returns > 0]
        losing_returns = returns[returns < 0]
        
        if len(winning_returns) > 0 and len(losing_returns) > 0:
            metrics['profit_loss_ratio'] = winning_returns.mean() / abs(losing_returns.mean())
        else:
            metrics['profit_loss_ratio'] = 0
        
        # ä¸åŸºå‡†æ¯”è¾ƒ
        if benchmark_returns is not None:
            # ä¿¡æ¯æ¯”ç‡
            excess_returns = returns - benchmark_returns
            tracking_error = excess_returns.std() * np.sqrt(252)
            
            if tracking_error > 0:
                metrics['information_ratio'] = excess_returns.mean() * 252 / tracking_error
            else:
                metrics['information_ratio'] = 0
            
            # Betaå’ŒAlpha
            covariance = np.cov(returns, benchmark_returns)[0, 1]
            benchmark_variance = np.var(benchmark_returns)
            
            if benchmark_variance > 0:
                metrics['beta'] = covariance / benchmark_variance
                risk_free_rate = 0.02  # å‡è®¾æ— é£é™©åˆ©ç‡ä¸º2%
                metrics['alpha'] = (metrics['annual_return'] - risk_free_rate) - \
                                 metrics['beta'] * (benchmark_returns.mean() * 252 - risk_free_rate)
            else:
                metrics['beta'] = 0
                metrics['alpha'] = 0
        
        # VaRå’ŒCVaR
        metrics['var_95'] = returns.quantile(0.05)
        metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()
        
        # æœ€å¤§è¿ç»­äºæŸå¤©æ•°
        losing_streaks = []
        current_streak = 0
        
        for ret in returns:
            if ret < 0:
                current_streak += 1
            else:
                if current_streak > 0:
                    losing_streaks.append(current_streak)
                current_streak = 0
        
        if current_streak > 0:
            losing_streaks.append(current_streak)
        
        metrics['max_losing_streak'] = max(losing_streaks) if losing_streaks else 0
        
        return metrics
    
    def generate_report(self, portfolio_history: List[Dict], 
                       benchmark_data: pd.DataFrame = None) -> Dict:
        """
        ç”Ÿæˆå®Œæ•´çš„ç»©æ•ˆæŠ¥å‘Š
        
        Args:
            portfolio_history: ç»„åˆå†å²æ•°æ®
            benchmark_data: åŸºå‡†æ•°æ®
            
        Returns:
            å®Œæ•´çš„ç»©æ•ˆæŠ¥å‘Š
        """
        # è½¬æ¢ä¸ºDataFrame
        df = pd.DataFrame(portfolio_history)
        df.set_index('date', inplace=True)
        
        # è®¡ç®—æ”¶ç›Šç‡
        returns = df['portfolio_value'].pct_change().dropna()
        
        # åŸºå‡†æ”¶ç›Šç‡
        benchmark_returns = None
        if benchmark_data is not None:
            benchmark_returns = benchmark_data['Close'].pct_change().dropna()
            # å¯¹é½æ—¥æœŸ
            common_dates = returns.index.intersection(benchmark_returns.index)
            returns = returns.loc[common_dates]
            benchmark_returns = benchmark_returns.loc[common_dates]
        
        # è®¡ç®—æŒ‡æ ‡
        metrics = self.calculate_metrics(returns, benchmark_returns)
        
        # ç”Ÿæˆå›¾è¡¨
        charts = self.create_charts(df, returns, benchmark_data)
        
        return {
            'metrics': metrics,
            'charts': charts,
            'returns_series': returns,
            'portfolio_history': df
        }
    
    def create_charts(self, portfolio_df: pd.DataFrame, 
                     returns: pd.Series,
                     benchmark_data: pd.DataFrame = None) -> Dict:
        """
        åˆ›å»ºç»©æ•ˆå›¾è¡¨
        
        Args:
            portfolio_df: ç»„åˆæ•°æ®
            returns: æ”¶ç›Šç‡åºåˆ—
            benchmark_data: åŸºå‡†æ•°æ®
            
        Returns:
            å›¾è¡¨å­—å…¸
        """
        charts = {}
        
        # 1. ç´¯è®¡æ”¶ç›Šæ›²çº¿
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('ç´¯è®¡æ”¶ç›Šæ›²çº¿', 'å›æ’¤æ›²çº¿', 'æ”¶ç›Šç‡åˆ†å¸ƒ', 'æ»šåŠ¨å¤æ™®æ¯”ç‡'),
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        # ç´¯è®¡æ”¶ç›Š
        cumulative_returns = (1 + returns).cumprod()
        fig.add_trace(
            go.Scatter(x=cumulative_returns.index, y=cumulative_returns.values,
                      name='ç­–ç•¥æ”¶ç›Š', line=dict(color='blue')),
            row=1, col=1
        )
        
        if benchmark_data is not None:
            benchmark_returns = benchmark_data['Close'].pct_change().dropna()
            common_dates = returns.index.intersection(benchmark_returns.index)
            benchmark_cum = (1 + benchmark_returns.loc[common_dates]).cumprod()
            fig.add_trace(
                go.Scatter(x=benchmark_cum.index, y=benchmark_cum.values,
                          name='åŸºå‡†æ”¶ç›Š', line=dict(color='red', dash='dash')),
                row=1, col=1
            )
        
        # å›æ’¤æ›²çº¿
        peak = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - peak) / peak
        fig.add_trace(
            go.Scatter(x=drawdown.index, y=drawdown.values,
                      name='å›æ’¤', fill='tonexty', line=dict(color='red')),
            row=1, col=2
        )
        
        # æ”¶ç›Šç‡åˆ†å¸ƒ
        fig.add_trace(
            go.Histogram(x=returns.values, name='æ”¶ç›Šç‡åˆ†å¸ƒ', nbinsx=50),
            row=2, col=1
        )
        
        # æ»šåŠ¨å¤æ™®æ¯”ç‡
        rolling_sharpe = returns.rolling(60).mean() / returns.rolling(60).std() * np.sqrt(252)
        fig.add_trace(
            go.Scatter(x=rolling_sharpe.index, y=rolling_sharpe.values,
                      name='60æ—¥æ»šåŠ¨å¤æ™®', line=dict(color='green')),
            row=2, col=2
        )
        
        fig.update_layout(height=800, showlegend=True, title_text="ç­–ç•¥ç»©æ•ˆåˆ†æ")
        charts['performance_overview'] = fig
        
        # 2. æœˆåº¦æ”¶ç›Šçƒ­åŠ›å›¾
        monthly_returns = returns.resample('M').apply(lambda x: (1 + x).prod() - 1)
        monthly_returns.index = monthly_returns.index.to_period('M')
        
        # åˆ›å»ºæœˆåº¦æ”¶ç›ŠçŸ©é˜µ
        years = monthly_returns.index.year.unique()
        months = range(1, 13)
        
        heatmap_data = []
        for year in years:
            year_data = []
            for month in months:
                try:
                    value = monthly_returns[f'{year}-{month:02d}']
                    year_data.append(value * 100)  # è½¬æ¢ä¸ºç™¾åˆ†æ¯”
                except KeyError:
                    year_data.append(np.nan)
            heatmap_data.append(year_data)
        
        fig_heatmap = go.Figure(data=go.Heatmap(
            z=heatmap_data,
            x=['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ',
               '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'],
            y=years,
            colorscale='RdYlGn',
            text=[[f'{val:.1f}%' if not np.isnan(val) else '' for val in row] for row in heatmap_data],
            texttemplate="%{text}",
            textfont={"size": 10},
            hoverongaps=False
        ))
        
        fig_heatmap.update_layout(
            title='æœˆåº¦æ”¶ç›Šç‡çƒ­åŠ›å›¾ (%)',
            xaxis_title='æœˆä»½',
            yaxis_title='å¹´ä»½'
        )
        charts['monthly_heatmap'] = fig_heatmap
        
        return charts
    
    def export_report(self, report: Dict, filename: str = 'performance_report.html'):
        """
        å¯¼å‡ºç»©æ•ˆæŠ¥å‘Šä¸ºHTMLæ–‡ä»¶
        
        Args:
            report: ç»©æ•ˆæŠ¥å‘Šå­—å…¸
            filename: è¾“å‡ºæ–‡ä»¶å
        """
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>é‡åŒ–ç­–ç•¥ç»©æ•ˆæŠ¥å‘Š</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .metric {{ margin: 10px 0; }}
                .metric-name {{ font-weight: bold; display: inline-block; width: 200px; }}
                .metric-value {{ color: #333; }}
                .positive {{ color: green; }}
                .negative {{ color: red; }}
            </style>
        </head>
        <body>
            <h1>é‡åŒ–ç­–ç•¥ç»©æ•ˆæŠ¥å‘Š</h1>
            <h2>å…³é”®ç»©æ•ˆæŒ‡æ ‡</h2>
        """
        
        # æ·»åŠ æŒ‡æ ‡
        for metric_name, value in report['metrics'].items():
            if isinstance(value, float):
                if 'return' in metric_name or 'ratio' in metric_name:
                    formatted_value = f"{value:.2%}" if 'return' in metric_name else f"{value:.2f}"
                    css_class = 'positive' if value > 0 else 'negative'
                else:
                    formatted_value = f"{value:.4f}"
                    css_class = 'negative' if 'drawdown' in metric_name and value < 0 else ''
            else:
                formatted_value = str(value)
                css_class = ''
            
            html_content += f"""
            <div class="metric">
                <span class="metric-name">{metric_name.replace('_', ' ').title()}:</span>
                <span class="metric-value {css_class}">{formatted_value}</span>
            </div>
            """
        
        html_content += """
            <h2>ç»©æ•ˆå›¾è¡¨</h2>
            <div id="charts"></div>
            <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
            <script>
                // è¿™é‡Œå¯ä»¥æ·»åŠ å›¾è¡¨çš„JavaScriptä»£ç 
            </script>
        </body>
        </html>
        """
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print(f"ç»©æ•ˆæŠ¥å‘Šå·²å¯¼å‡ºåˆ°: {filename}")
```

---

## ğŸš€ ç¬¬å…­æ­¥ï¼šå¿«é€Ÿå¯åŠ¨ç¤ºä¾‹

### 6.1 å®Œæ•´çš„ç­–ç•¥æµ‹è¯•ç¤ºä¾‹

```python
# examples/quick_start_example.py

import sys
sys.path.append('../src')

from data.data_sources import DataManager
from backtest.backtest_engine import BacktestEngine
from strategy.strategy_templates import MomentumStrategy, MeanReversionStrategy
from backtest.performance_analyzer import PerformanceAnalyzer
import pandas as pd
from datetime import datetime, timedelta

def main():
    """
    é‡åŒ–äº¤æ˜“ç³»ç»Ÿå¿«é€Ÿå¯åŠ¨ç¤ºä¾‹
    """
    print("ğŸš€ å¯åŠ¨é‡åŒ–äº¤æ˜“ç³»ç»Ÿæµ‹è¯•...")
    
    # 1. åˆå§‹åŒ–æ•°æ®ç®¡ç†å™¨
    data_manager = DataManager()
    
    # 2. è·å–æµ‹è¯•æ•°æ®
    symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA']
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=365*2)).strftime('%Y-%m-%d')
    
    print(f"ğŸ“Š è·å–æ•°æ®: {symbols}")
    print(f"ğŸ“… æ—¶é—´èŒƒå›´: {start_date} åˆ° {end_date}")
    
    # è·å–è‚¡ç¥¨æ•°æ®
    stock_data = {}
    for symbol in symbols:
        data = data_manager.get_stock_data([symbol], start_date, end_date)
        if not data.empty:
            stock_data[symbol] = data
            print(f"âœ… {symbol}: {len(data)} æ¡æ•°æ®")
        else:
            print(f"âŒ {symbol}: æ•°æ®è·å–å¤±è´¥")
    
    if not stock_data:
        print("âŒ æ²¡æœ‰è·å–åˆ°ä»»ä½•æ•°æ®ï¼Œé€€å‡ºæµ‹è¯•")
        return
    
    # 3. åˆå§‹åŒ–å›æµ‹å¼•æ“
    backtest_engine = BacktestEngine(
        initial_capital=1000000,  # 100ä¸‡åˆå§‹èµ„é‡‘
        commission=0.001,         # 0.1%æ‰‹ç»­è´¹
        slippage=0.001           # 0.1%æ»‘ç‚¹
    )
    
    # 4. æµ‹è¯•åŠ¨é‡ç­–ç•¥
    print("\nğŸ“ˆ æµ‹è¯•åŠ¨é‡ç­–ç•¥...")
    momentum_strategy = MomentumStrategy(
        short_window=10,
        long_window=30,
        max_position_size=1000
    )
    
    momentum_results = backtest_engine.run_backtest(
        data=stock_data,
        strategy_func=momentum_strategy.generate_signals,
        start_date=start_date,
        end_date=end_date
    )
    
    print("åŠ¨é‡ç­–ç•¥å›æµ‹ç»“æœ:")
    for key, value in momentum_results.items():
        if key not in ['portfolio_history', 'trade_history']:
            if isinstance(value, float):
                print(f"  {key}: {value:.4f}")
            else:
                print(f"  {key}: {value}")
    
    # 5. æµ‹è¯•å‡å€¼å›å½’ç­–ç•¥
    print("\nğŸ“‰ æµ‹è¯•å‡å€¼å›å½’ç­–ç•¥...")
    mean_reversion_strategy = MeanReversionStrategy(
        lookback_period=20,
        entry_threshold=2.0,
        exit_threshold=0.5,
        max_position_size=1000
    )
    
    backtest_engine.reset()  # é‡ç½®å›æµ‹å¼•æ“
    
    mean_reversion_results = backtest_engine.run_backtest(
        data=stock_data,
        strategy_func=mean_reversion_strategy.generate_signals,
        start_date=start_date,
        end_date=end_date
    )
    
    print("å‡å€¼å›å½’ç­–ç•¥å›æµ‹ç»“æœ:")
    for key, value in mean_reversion_results.items():
        if key not in ['portfolio_history', 'trade_history']:
            if isinstance(value, float):
                print(f"  {key}: {value:.4f}")
            else:
                print(f"  {key}: {value}")
    
    # 6. ç»©æ•ˆåˆ†æ
    print("\nğŸ“Š ç”Ÿæˆç»©æ•ˆåˆ†ææŠ¥å‘Š...")
    analyzer = PerformanceAnalyzer()
    
    # è·å–åŸºå‡†æ•°æ®ï¼ˆSPYï¼‰
    benchmark_data = data_manager.get_stock_data(['SPY'], start_date, end_date)
    
    # ç”ŸæˆåŠ¨é‡ç­–ç•¥æŠ¥å‘Š
    momentum_report = analyzer.generate_report(
        momentum_results['portfolio_history'],
        benchmark_data
    )
    
    # å¯¼å‡ºæŠ¥å‘Š
    analyzer.export_report(momentum_report, 'momentum_strategy_report.html')
    
    print("âœ… æµ‹è¯•å®Œæˆï¼")
    print("ğŸ“„ ç»©æ•ˆæŠ¥å‘Šå·²ç”Ÿæˆ: momentum_strategy_report.html")
    print("\nğŸ¯ ä¸‹ä¸€æ­¥å»ºè®®:")
    print("  1. è°ƒæ•´ç­–ç•¥å‚æ•°è¿›è¡Œä¼˜åŒ–")
    print("  2. æ·»åŠ æ›´å¤šæŠ€æœ¯æŒ‡æ ‡")
    print("  3. å®ç°é£é™©ç®¡ç†æ¨¡å—")
    print("  4. é›†æˆå®ç›˜äº¤æ˜“æ¥å£")

if __name__ == "__main__":
    main()
```

### 6.2 é…ç½®æ–‡ä»¶æ¨¡æ¿

```python
# config/settings.py

import os
from typing import Dict, Any

class Settings:
    """
    ç³»ç»Ÿé…ç½®ç±»
    """
    
    # æ•°æ®åº“é…ç½®
    DATABASE_URL = os.getenv(
        'DATABASE_URL',
        'postgresql://username:password@localhost:5432/quant_db'
    )
    
    # Redisé…ç½®
    REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
    
    # APIé…ç½®
    ALPHA_VANTAGE_API_KEY = os.getenv('ALPHA_VANTAGE_API_KEY', '')
    QUANDL_API_KEY = os.getenv('QUANDL_API_KEY', '')
    IEX_CLOUD_API_KEY = os.getenv('IEX_CLOUD_API_KEY', '')
    
    # äº¤æ˜“é…ç½®
    DEFAULT_COMMISSION = 0.001  # 0.1%
    DEFAULT_SLIPPAGE = 0.001    # 0.1%
    MAX_POSITION_SIZE = 0.1     # å•ä¸ªæŒä»“æœ€å¤§å æ¯”10%
    
    # é£é™©ç®¡ç†é…ç½®
    MAX_DRAWDOWN_LIMIT = 0.15   # æœ€å¤§å›æ’¤é™åˆ¶15%
    STOP_LOSS_THRESHOLD = 0.05  # æ­¢æŸé˜ˆå€¼5%
    POSITION_SIZE_LIMIT = 0.2   # å•ä¸ªè‚¡ç¥¨æœ€å¤§ä»“ä½20%
    
    # å›æµ‹é…ç½®
    DEFAULT_INITIAL_CAPITAL = 1000000  # é»˜è®¤åˆå§‹èµ„é‡‘100ä¸‡
    BENCHMARK_SYMBOL = 'SPY'           # é»˜è®¤åŸºå‡†
    
    # æ—¥å¿—é…ç½®
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
    LOG_FILE = 'logs/quant_system.log'
    
    @classmethod
    def get_trading_config(cls) -> Dict[str, Any]:
        """
        è·å–äº¤æ˜“ç›¸å…³é…ç½®
        """
        return {
            'commission': cls.DEFAULT_COMMISSION,
            'slippage': cls.DEFAULT_SLIPPAGE,
            'max_position_size': cls.MAX_POSITION_SIZE,
            'initial_capital': cls.DEFAULT_INITIAL_CAPITAL
        }
    
    @classmethod
    def get_risk_config(cls) -> Dict[str, Any]:
        """
        è·å–é£é™©ç®¡ç†é…ç½®
        """
        return {
            'max_drawdown_limit': cls.MAX_DRAWDOWN_LIMIT,
            'stop_loss_threshold': cls.STOP_LOSS_THRESHOLD,
            'position_size_limit': cls.POSITION_SIZE_LIMIT
        }
```

---

## ğŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### âœ… ç¬¬ä¸€å‘¨ä»»åŠ¡æ¸…å•

- [ ] **ç¯å¢ƒæ­å»º**
  - [ ] Python 3.9+ ç¯å¢ƒé…ç½®
  - [ ] è™šæ‹Ÿç¯å¢ƒåˆ›å»º
  - [ ] ä¾èµ–åŒ…å®‰è£…
  - [ ] IDEé…ç½®ï¼ˆæ¨èVS Code + Pythonæ’ä»¶ï¼‰

- [ ] **é¡¹ç›®ç»“æ„**
  - [ ] åˆ›å»ºé¡¹ç›®ç›®å½•ç»“æ„
  - [ ] åˆå§‹åŒ–Gitä»“åº“
  - [ ] é…ç½®.gitignore
  - [ ] ç¼–å†™README.md

- [ ] **æ•°æ®è·å–**
  - [ ] å®ç°DataManagerç±»
  - [ ] æµ‹è¯•yfinanceæ•°æ®è·å–
  - [ ] éªŒè¯æ•°æ®è´¨é‡
  - [ ] å»ºç«‹æ•°æ®ç¼“å­˜æœºåˆ¶

### âœ… ç¬¬äºŒå‘¨ä»»åŠ¡æ¸…å•

- [ ] **å› å­è®¡ç®—**
  - [ ] å®ç°æŠ€æœ¯æŒ‡æ ‡è®¡ç®—
  - [ ] æµ‹è¯•å› å­è®¡ç®—å‡†ç¡®æ€§
  - [ ] å»ºç«‹å› å­åº“
  - [ ] å®ç°å› å­æ ‡å‡†åŒ–

- [ ] **ç­–ç•¥æ¡†æ¶**
  - [ ] å®ç°ç­–ç•¥åŸºç±»
  - [ ] å¼€å‘åŠ¨é‡ç­–ç•¥
  - [ ] å¼€å‘å‡å€¼å›å½’ç­–ç•¥
  - [ ] ç­–ç•¥å‚æ•°ä¼˜åŒ–æ¡†æ¶

### âœ… ç¬¬ä¸‰å‘¨ä»»åŠ¡æ¸…å•

- [ ] **å›æµ‹å¼•æ“**
  - [ ] å®ç°BacktestEngineæ ¸å¿ƒåŠŸèƒ½
  - [ ] äº¤æ˜“æˆæœ¬è®¡ç®—
  - [ ] æŒä»“ç®¡ç†
  - [ ] å›æµ‹ç»“æœè®°å½•

- [ ] **ç»©æ•ˆåˆ†æ**
  - [ ] å®ç°PerformanceAnalyzer
  - [ ] å…³é”®æŒ‡æ ‡è®¡ç®—
  - [ ] å›¾è¡¨ç”Ÿæˆ
  - [ ] æŠ¥å‘Šå¯¼å‡º

### âœ… ç¬¬å››å‘¨ä»»åŠ¡æ¸…å•

- [ ] **ç³»ç»Ÿé›†æˆ**
  - [ ] ç«¯åˆ°ç«¯æµ‹è¯•
  - [ ] æ€§èƒ½ä¼˜åŒ–
  - [ ] é”™è¯¯å¤„ç†
  - [ ] æ—¥å¿—ç³»ç»Ÿ

- [ ] **æ–‡æ¡£å®Œå–„**
  - [ ] APIæ–‡æ¡£
  - [ ] ä½¿ç”¨æŒ‡å—
  - [ ] ç­–ç•¥å¼€å‘æ•™ç¨‹
  - [ ] éƒ¨ç½²æŒ‡å—

---

## ğŸ¯ æˆåŠŸå…³é”®è¦ç´ 

### 1. æŠ€æœ¯è¦ç´ 
- **æ•°æ®è´¨é‡**: ç¡®ä¿æ•°æ®å‡†ç¡®ã€å®Œæ•´ã€åŠæ—¶
- **å›æµ‹å‡†ç¡®æ€§**: é¿å…æœªæ¥ä¿¡æ¯æ³„éœ²ï¼Œè€ƒè™‘äº¤æ˜“æˆæœ¬
- **ä»£ç è´¨é‡**: æ¨¡å—åŒ–è®¾è®¡ï¼Œå……åˆ†æµ‹è¯•ï¼Œæ–‡æ¡£å®Œå–„
- **æ€§èƒ½ä¼˜åŒ–**: é«˜æ•ˆçš„æ•°æ®å¤„ç†å’Œè®¡ç®—

### 2. ç­–ç•¥è¦ç´ 
- **é€»è¾‘æ¸…æ™°**: ç­–ç•¥é€»è¾‘ç®€å•æ˜äº†ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤
- **å‚æ•°ç¨³å¥**: ç­–ç•¥å‚æ•°åœ¨ä¸åŒå¸‚åœºç¯å¢ƒä¸‹è¡¨ç°ç¨³å®š
- **é£é™©æ§åˆ¶**: å®Œå–„çš„é£é™©ç®¡ç†æœºåˆ¶
- **é€‚åº”æ€§å¼º**: èƒ½å¤Ÿé€‚åº”å¸‚åœºå˜åŒ–

### 3. å›¢é˜Ÿè¦ç´ 
- **æ˜ç¡®åˆ†å·¥**: CTOè´Ÿè´£æŠ€æœ¯ï¼ŒCEOè´Ÿè´£ä¸šåŠ¡
- **æŒç»­å­¦ä¹ **: è·Ÿä¸Šæœ€æ–°çš„é‡åŒ–æŠ€æœ¯å’Œå¸‚åœºåŠ¨æ€
- **ä¸¥æ ¼æµ‹è¯•**: æ¯ä¸ªæ¨¡å—éƒ½è¦ç»è¿‡å……åˆ†æµ‹è¯•
- **è¿­ä»£æ”¹è¿›**: æŒç»­ä¼˜åŒ–å’Œæ”¹è¿›ç³»ç»Ÿ

---

## ğŸš¨ å¸¸è§é™·é˜±ä¸é¿å…æ–¹æ³•

### 1. æ•°æ®é™·é˜±
- **æœªæ¥ä¿¡æ¯æ³„éœ²**: ä½¿ç”¨äº†å½“æ—¶ä¸å¯è·å¾—çš„æ•°æ®
- **ç”Ÿå­˜åå·®**: åªè€ƒè™‘äº†å­˜æ´»çš„è‚¡ç¥¨
- **æ•°æ®è´¨é‡é—®é¢˜**: åˆ†çº¢è°ƒæ•´ã€è‚¡ç¥¨åˆ†æ‹†ç­‰å¤„ç†ä¸å½“

**é¿å…æ–¹æ³•**: ä¸¥æ ¼çš„æ•°æ®éªŒè¯ï¼Œä½¿ç”¨point-in-timeæ•°æ®

### 2. å›æµ‹é™·é˜±
- **è¿‡åº¦æ‹Ÿåˆ**: ç­–ç•¥è¿‡åº¦ä¼˜åŒ–å†å²æ•°æ®
- **äº¤æ˜“æˆæœ¬å¿½ç•¥**: æœªè€ƒè™‘æ‰‹ç»­è´¹ã€æ»‘ç‚¹ã€å†²å‡»æˆæœ¬
- **æµåŠ¨æ€§å‡è®¾**: å‡è®¾å¯ä»¥æ— é™åˆ¶äº¤æ˜“

**é¿å…æ–¹æ³•**: æ ·æœ¬å¤–æµ‹è¯•ï¼Œä¿å®ˆçš„æˆæœ¬ä¼°è®¡ï¼Œè€ƒè™‘å¸‚åœºå®¹é‡

### 3. ç­–ç•¥é™·é˜±
- **å¤æ‚åº¦è¿‡é«˜**: ç­–ç•¥è¿‡äºå¤æ‚ï¼Œéš¾ä»¥ç†è§£å’Œç»´æŠ¤
- **å‚æ•°è¿‡å¤š**: å‚æ•°å¤ªå¤šå¯¼è‡´è¿‡æ‹Ÿåˆ
- **å¸‚åœºç¯å¢ƒå˜åŒ–**: ç­–ç•¥æ— æ³•é€‚åº”æ–°çš„å¸‚åœºç¯å¢ƒ

**é¿å…æ–¹æ³•**: ä¿æŒç­–ç•¥ç®€å•ï¼Œå‡å°‘å‚æ•°ï¼Œå®šæœŸé‡æ–°è¯„ä¼°

---

## ğŸ“š æ¨èå­¦ä¹ èµ„æº

### ä¹¦ç±æ¨è
1. **ã€Šé‡åŒ–æŠ•èµ„ï¼šç­–ç•¥ä¸æŠ€æœ¯ã€‹** - ä¸é¹
2. **ã€ŠPythoné‡‘èå¤§æ•°æ®åˆ†æã€‹** - Yves Hilpisch
3. **ã€Šç®—æ³•äº¤æ˜“ï¼šåˆ¶èƒœç­–ç•¥ä¸åŸç†ã€‹** - Ernest P. Chan
4. **ã€Šé‡åŒ–äº¤æ˜“å¦‚ä½•å»ºç«‹è‡ªå·±çš„ç®—æ³•äº¤æ˜“äº‹ä¸šã€‹** - Ernest P. Chan

### åœ¨çº¿èµ„æº
1. **QuantConnect**: é‡åŒ–äº¤æ˜“å¹³å°å’Œç¤¾åŒº
2. **Quantopian**: é‡åŒ–ç­–ç•¥ç ”ç©¶å¹³å°ï¼ˆå·²å…³é—­ï¼Œä½†èµ„æ–™ä»æœ‰ä»·å€¼ï¼‰
3. **GitHub**: å¼€æºé‡åŒ–é¡¹ç›®
4. **Kaggle**: é‡‘èæ•°æ®ç§‘å­¦ç«èµ›

### Pythonåº“æ¨è
1. **zipline**: ç®—æ³•äº¤æ˜“åº“
2. **backtrader**: å›æµ‹æ¡†æ¶
3. **pyfolio**: ç»©æ•ˆåˆ†æ
4. **alphalens**: å› å­åˆ†æ
5. **empyrical**: é£é™©å’Œç»©æ•ˆæŒ‡æ ‡

---

## ğŸ‰ æ€»ç»“

è¿™ä»½èµ·æ­¥æŒ‡å—ä¸ºä¸¤äººå›¢é˜Ÿæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„é‡åŒ–äº¤æ˜“ç³»ç»Ÿå¼€å‘è·¯çº¿å›¾ã€‚é€šè¿‡æŒ‰ç…§è¿™ä¸ªæŒ‡å—é€æ­¥å®æ–½ï¼Œä½ ä»¬å¯ä»¥åœ¨4-6å‘¨å†…å»ºç«‹èµ·ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„é‡åŒ–äº¤æ˜“ç³»ç»ŸåŸå‹ã€‚

**å…³é”®æˆåŠŸå› ç´ **:
1. **å¾ªåºæ¸è¿›**: æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®ç°åŠŸèƒ½
2. **è´¨é‡ä¼˜å…ˆ**: ç¡®ä¿æ¯ä¸ªæ¨¡å—çš„è´¨é‡å’Œç¨³å®šæ€§
3. **æŒç»­æµ‹è¯•**: åœ¨å¼€å‘è¿‡ç¨‹ä¸­ä¸æ–­æµ‹è¯•å’ŒéªŒè¯
4. **æ–‡æ¡£å®Œå–„**: ä¿æŒè‰¯å¥½çš„ä»£ç æ–‡æ¡£å’Œä½¿ç”¨è¯´æ˜
5. **é£é™©æ„è¯†**: å§‹ç»ˆç‰¢è®°é£é™©ç®¡ç†çš„é‡è¦æ€§

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:
1. ç«‹å³å¼€å§‹ç¯å¢ƒæ­å»º
2. æŒ‰ç…§æ£€æŸ¥æ¸…å•é€é¡¹å®Œæˆ
3. æ¯å‘¨è¿›è¡Œè¿›åº¦å›é¡¾
4. é‡åˆ°é—®é¢˜åŠæ—¶è°ƒæ•´è®¡åˆ’

ç¥ä½ ä»¬åœ¨é‡åŒ–æŠ•èµ„çš„é“è·¯ä¸Šå–å¾—æˆåŠŸï¼ğŸš€